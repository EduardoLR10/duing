#+hugo_base_dir: ../
#+hugo_tags: lesson recommendation

#+title: Zigging out of Lambdas

#+date: 2024-08-01
#+author: Eduardo Lemos

You envision a generic way to implement a particular functionality.
In the process of implementing it, however, you notice that some pieces of the code
really bother you. Not because they are /wrong/, stuff works and all, but because it
feels like you had to bend the tool you are using to get the result. It is not the most
pleasant type of hacking. This post is about an experience of this phenomena.

In the spirit of having a more concrete example of my previous post, [[file:../defaultsAreNotDogmas/][Don't make all defaults Dogmas]],
today I will describe a very small feature I had to implement in one of my personal projects, and how
the initial version that I *wanted* to implement turned out not that amazing due to how uncomfortable I was
after using some magical tricks to make it happen.

* Context

You are making your game, implemented in Zig, during your free time after work. In this particular session, the
hanging fruit is some sort of /asset loader/. You want to have a very nice interface that you pass the file path
of the asset, that being an image, audio, model, texture, etc, and the function just returns it. To make
the experience nice for the caller of the function, we will prefix the provided file path with some sort of /base file path/,
so then if the assets' folder moves to somewhere else in the file system, only the loading functions for assets need to change, nothing else.

* First Implementation

Let's decide that the first draft will be for image loading. We come up with this as our first attempt:

#+begin_src zig
const rl = @import("raylib");
const std = @import("std");

const base_filepath = "./assets/";

fn checkExtension(filePath: [:0]const u8, extensions: []const [:0]const u8) bool {
    const fileExtension = std.fs.path.extension(filePath);
    for (extensions) |extension| {
        if (std.mem.eql(u8, fileExtension, extension)) {
            return true;
        }
    }
    return false;
}

pub fn image(imageFilePath: [:0]const u8) !rl.Image {
    const allocator: std.mem.Allocator = std.heap.c_allocator;
    const fullFilePath = try std.fs.path.joinZ(allocator, &.{ base_filepath, imageFilePath });
    defer allocator.free(fullFilePath);
    if (checkExtension(imageFilePath, &.{ ".png", ".jpg" })) {
        return rl.loadImage(fullFilePath);
    } else {
        std.debug.print("Error trying to load image: .{s}", .{fullFilePath});
        return error.could_not_load_image;
    }
}
#+end_src

With the image's file path on hand, we first instantiate an ~allocator~. We'll use it to create the full file path of the
asset, i.e., add the prefix ~base_filepath~. This string will have no use after we load the image, hence we ~defer~ to free it.
Just before we load the asset, we do a naive check of the provided file. Only files with the extension ~".png"~ or ~".jpg"~
will have a chance to be loaded as an image. Otherwise, we just fail logging an error message for debugging purposes. When calling the function ~image~,
within the Struct ~assets~ (files in Zig behave like Structs), the user will just call ~assets.image("my_image.png");~ and the job is done.

Now, imagine that you don't want to only have images: what about models? And textures? Well...

#+begin_src zig
pub fn model(modelFilePath: [:0]const u8) !rl.Model {
    const allocator: std.mem.Allocator = std.heap.c_allocator;
    const fullFilePath = try std.fs.path.joinZ(allocator, &.{ base_filepath, modelFilePath });
    defer allocator.free(fullFilePath);
    if (checkExtension(modelFilePath, &.{ ".glb", ".obj" })) {
        return rl.loadModel(fullFilePath);
    } else {
        std.debug.print("Error trying to load model: .{s}", .{fullFilePath});
	return error.could_not_load_model;
    }
}

pub fn texture(textureFilePath: [:0]const u8) !rl.Texture2D {
    const allocator: std.mem.Allocator = std.heap.c_allocator;
    const fullFilePath = try std.fs.path.joinZ(allocator, &.{ base_filepath, textureFilePath });
    defer allocator.free(fullFilePath);
    if (checkExtension(textureFilePath, &.{ ".png", ".jpg" })) {
        return rl.loadTexture(fullFilePath);
    } else {
        std.debug.print("Error trying to load texture: .{s}", .{fullFilePath});
	return error.could_not_load_texture;
    }
}
#+end_src

Underwhelming, isn't it? We have *three* functions that have more similarities than differences. In fact,
most of the bodies of these functions are identical. The boilerplate is palpable. What can we do to improve this?

* Different Mindset

You, being a Functional Programming (FP) fan, had an idea. What if we use the powers of lambdas and type programming to make things
more generic? After some thinking, you ended up with this draft:

#+begin_src zig
const rl = @import("raylib");
const std = @import("std");

const base_filepath = "./assets/";

fn load(comptime filePath: [:0]const u8, comptime T: type, loader: fn ([:0]const u8) T, predicate: fn ([:0]const u8) bool) !T {
    const allocator: std.mem.Allocator = std.heap.c_allocator;

    const fullFilePath = try std.fs.path.joinZ(allocator, &.{ base_filepath, filePath });
    defer allocator.free(fullFilePath);

    if (predicate(fullFilePath)) {
        return loader(fullFilePath);
    } else {
        std.debug.print("Error trying to load file: .{s}", .{fullFilePath});
        return error.could_not_load_asset;
    }
}

fn checkExtension(extensions: []const [:0]const u8) (fn ([:0]const u8) bool) {
    return struct {
        fn check(filePath: [:0]const u8) bool {
	    const fileExtension = std.fs.path.extension(filePath);
	    for (extensions) |extension| {
	        if (std.mem.eql(u8, fileExtension, extension)) {
		    return true;
	        }
	    }
	    return false;
	}
    }.check;
}
  
pub fn image(comptime imageFilePath: [:0]const u8) !rl.Image {
    return load(imageFilePath, rl.Image, rl.loadImage, checkExtension(&.{ ".png", ".jpg" }));
}

pub fn model(comptime modelFilePath: [:0]const u8) !rl.Model {
    return load(modelFilePath, rl.Model, rl.loadModel, checkExtension(&.{ ".glb", ".obj" }));
}

pub fn texture(comptime textureFilePath: [:0]const u8) !rl.Texture2D {
    return load(textureFilePath, rl.Texture2D, rl.loadTexture, checkExtension(&.{ ".png", "jpg" }));
}
#+end_src

Although a little different than primary FP languages, we managed to shrink a lot code, basically eliminating
the previous boilerplate. This didn't come for /free/ though, as we are about to see later on.

Most of the functionality now lives under a function called ~load~, which is not being exposed for the user. This function
requires: the asset's file path, the type of the data we will return (we're using Zig's compile-time reflection here), which
loading function we will use, and finally a predicate to validate the file before loading. To make things simple, we are doing
the same extension check as before.

At first glance, we did it. But, why do I look at that and feel that something is wrong although it works?

* Trade-Offs

The latest implementation, although it compiles and it works, feels uneasy to read. A few tricks were required to make it work:
we introduced Zig's reflection to the party *only* to be able to have generic returns (we need to bind the return type to a name).
Did anybody noticed ~checkExtension~? This function is using a very specific trick [1]. Since Struct declarations are anonymous, we've
declared a Struct and immediately return a member function from it. This way we can keep the argument of the outter function, ~extensions~,
still in scope and return another function from it. We use this later in ~load~ as our predicate of choice (you could do something way fancier,
like checking the internal header of the file, etc).

The first implementation, although with heavy boilerplate, even has some advantages: our error messages are more precise about which asset failed
to load, rather than just saying "failed to load a generic file", there is no ~comptime~s floating around, even if they were simple ones, and there
is no Struct hack to have anonoymous lambdas in the code.

* Conclusion

At this point, my mind uses FP as my default for everything. My mind works like this:

#+attr_html: :width 60%
[[/img/ziggingLambdas/mind.png]]

However, when faced with a particular set of tools, specially imperative ones, I find that trying to follow my default with no exceptions can lead
to less maintanable, predictable, and efficient code. The latter aspect, in terms of its importance, may vary from application to application, but the first
two points basically always matter. If the tool that I'm suppose to use comes with a specific set of premises, I gotta be careful about not following them.

Doing the development of this game, this was the second time this happened. The first time it was about using or not a clear and pure separation between
the game's logic and its render (I mentioned this case in the post  [[file:../defaultsAreNotDogmas/][Don't make all defaults Dogmas]]). Now, it was about asset loading management.

It may be the case that somewhere in the wild, there is a silver bullet on the corner; a tool so flexible that it fits into everything. I'll write a blog post
when and if I happen to find it.

* References

1. https://ziggit.dev/t/anonymous-functions-lambdas/1087/2
