<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>
  write: broken pipe

    </title>
    
    <link rel="stylesheet" href="/css/main.min.2b661d17033c8e88dcb9551cb00d5235c93175108db6ef12ccc009cce52bdd00.css" /><meta property="og:title" content="write: broken pipe" />
<meta property="og:description" content="  The adventure of figuring out the &#34;tcp: write: broken pipe&#34; error.
  " />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://glorifiedgluer.com/blog/2022/write-broken-pipe/" /><meta property="article:section" content="blog" />
<meta property="article:published_time" content="2022-04-06T00:00:00+00:00" />
<meta property="article:modified_time" content="2022-04-06T00:00:00+00:00" />

</head>
  <body><nav>
  <img
    src="/img/nana-icons/shiba-computer-low.jpg"
    alt="A shiba using the computer"
    width="128"
    height="128"
  />
  <h1>~glorifiedgluer</h1>
  <ul>
    <li><a href="/">Home</a></li>
    <li><a href="/about">About</a></li>
    <li><a href="/blog">Blog</a></li>
    <li><a href="/blogroll">Blogroll</a></li>
  </ul>
</nav>
<main>
  <h2>write: broken pipe
    <small>
      <time>April 6, 2022</time>
    by ~glorifiedgluer


    </small>
  </h2><p><strong>tl;dr</strong>: <a href="https://docs.konghq.com/kubernetes-ingress-controller/">Kong Ingress Controller</a> was the culprit. Its timeout setting was
closing the connection before the file could be sent. /If you&rsquo;re facing this
issue in a long-lasting request, check your reverse proxy configuration, as it
may have a different configuration than your application./ ;-)</p>
<p>At Grupo SBF we have an HTTP server written in <a href="https://go.dev/">Go</a> that queries <a href="https://cloud.google.com/bigquery">BigQuery</a> and
returns the result as a <strong>big</strong> csv file. However, after some time we sent a
request and instead of a file, we received this error message:</p>
<div class="highlight">
    <span class="highlight-type">nil</span>
    <pre><code class="language-nil hljs" data-lang="nil">write tcp 10.0.0.1:8080-&gt;10.0.0.2:38302: write: broken pipe</code></pre>
</div>

<style>
    .highlight-type {
        content: "nil";
        position: absolute;
        opacity: 0.5;
    }
</style><p>Well, this is quite a surprise as we haven&rsquo;t seen this error message before&hellip;
After all, what does it even mean? A quick Google search returned this:</p>
<blockquote>
<p>A condition in programming (also known in POSIX as EPIPE error code and SIGPIPE
signal), when a process requests an output to pipe or socket, which was closed
by peer. &ndash; <a href="https://en.wikipedia.org/wiki/Broken_pipe">Wikipedia</a></p>
</blockquote>
<p>Hmm, this <em>definitely</em> shed some light on the problem. Considering that the HTTP
server is provided by the powerful <a href="https://pkg.go.dev/net/http">net/http</a> package in Go&rsquo;s standard library, we
might have some obvious places to check out.</p>
<p>Cloudflare has a <a href="https://blog.cloudflare.com/exposing-go-on-the-internet/">great article</a> talking about the default configuration on Go&rsquo;s
HTTP server and how to avoid making mistakes with them. We jumped straight to
the article&rsquo;s timeout section and checked if we didn&rsquo;t forget to configure them.</p>
<div class="highlight">
    <span class="highlight-type">go</span>
    <pre><code class="language-go hljs" data-lang="go">srv := &amp;http.Server{
    ReadTimeout:  10 * time.Minute, // 10 minutes
    WriteTimeout: 10 * time.Minute,
    Addr:         &#34;:8080&#34;,
    Handler:      r,
}</code></pre>
</div>

<style>
    .highlight-type {
        content: "go";
        position: absolute;
        opacity: 0.5;
    }
</style><p>For context, our application takes about 2 minutes to send a response so this
isn&rsquo;t a problem for us as we have 10 minutes until a <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/504">504 server error</a> is
returned.</p>
<p>To our amazement, sending the request to a local server returned no error
whatsoever. Comparing our local environment with production we also noticed that
our request was <em>dropped</em> at exactly 1 minute of execution in production.
Therefore it must be something between our client and server!</p>
<p>Knowing that we deploy to a Kubernetes cluster with a <a href="https://docs.konghq.com/kubernetes-ingress-controller/">Kong Ingress Controller</a>
_{controlling} taking care of our reverse proxy, we checked its documentation
and&hellip; Bingo! This is the root of our problem, as per the <a href="https://docs.konghq.com/gateway/1.1.x/reference/proxy/#3-proxying-and-upstream-timeouts">Kong Ingress
Controller Documentation</a> the default timeout is <code>60_000</code> milliseconds &ndash; in
other words, 1 minute!</p>
<h2 id="replicating-the-behavior">Replicating the behavior</h2>
<p>Before trying something on our servers, why don&rsquo;t we replicate this behavior
locally? For this purpose we can run a <code>nginx</code> container and a simple Go HTTP
server with a similar functionality of our service.</p>
<p>The idea behind the test is to setup an endpoint that takes a lot of time
writing on the buffer while our reverse proxy has a timeout of only 2 seconds.</p>
<h3 id="go-server-and-dockerfile">Go server and Dockerfile</h3>
<div class="highlight">
    <span class="highlight-type">go</span>
    <pre><code class="language-go hljs" data-lang="go">func main() {
    mux := http.NewServeMux()
    mux.HandleFunc(&#34;/&#34;, func(w http.ResponseWriter, r *http.Request) {
        time.Sleep(time.Second * 10)

        // creating a large data size
        // that will take a long time to be written
        size := 900 * 1000 * 1000
        tpl := make([]byte, size)
        t, err := template.New(&#34;page&#34;).Parse(string(tpl))
        if err != nil {
            log.Printf(&#34;error parsing template: %s&#34;, err)
            return
        }

        if err := t.Execute(w, nil); err != nil {
            log.Printf(&#34;error writing: %s&#34;, err)
            return
        }
    })

    srv := &amp;http.Server{
        ReadTimeout: 10 * time.Minute,
        WriteTimeout: 10 * time.Minute,
        Addr: &#34;:8080&#34;,
        Handler: mux,
    }

    log.Println(&#34;server is running!&#34;)
    log.Println(srv.ListenAndServe())
}</code></pre>
</div>

<style>
    .highlight-type {
        content: "go";
        position: absolute;
        opacity: 0.5;
    }
</style><p>And then the Dockerfile:</p>
<div class="highlight">
    <span class="highlight-type">Dockerfile</span>
    <pre><code class="language-Dockerfile hljs" data-lang="Dockerfile"># server.Dockerfile
FROM golang:alpine AS build
RUN apk --no-cache add gcc g&#43;&#43; make git
WORKDIR /go/src/app
COPY . .
RUN go mod init server
RUN go mod tidy
RUN GOOS=linux go build -ldflags=&#34;-s -w&#34; -o ./bin/web-app ./server.go

FROM alpine:3.13
RUN apk --no-cache add ca-certificates
WORKDIR /usr/bin
COPY --from=build /go/src/app/bin /go/bin
EXPOSE 8080
ENTRYPOINT /go/bin/web-app --port 8080</code></pre>
</div>

<style>
    .highlight-type {
        content: "Dockerfile";
        position: absolute;
        opacity: 0.5;
    }
</style><h3 id="nginx-configuration-and-dockerfile">nginx configuration and Dockerfile</h3>
<div class="highlight">
    <span class="highlight-type">cfg</span>
    <pre><code class="language-cfg hljs" data-lang="cfg"># nginx.conf
events {
    worker_connections 1024;
}

http {
  server_tokens off;
  server {
    listen 80;

    location / {
      proxy_set_header X-Forwarded-For $remote_addr;
      proxy_set_header Host            $http_host;

      # timeout set to 2 seconds
      proxy_read_timeout 2s;
      proxy_connect_timeout 2s;
      proxy_send_timeout 2s;

      proxy_pass http://goservice:8080/;
    }
  }
}</code></pre>
</div>

<style>
    .highlight-type {
        content: "cfg";
        position: absolute;
        opacity: 0.5;
    }
</style><p>And then the Dockerfile:</p>
<div class="highlight">
    <span class="highlight-type">Dockerfile</span>
    <pre><code class="language-Dockerfile hljs" data-lang="Dockerfile"># nginx.Dockerfile
FROM nginx:latest
EXPOSE 80
COPY nginx.conf /etc/nginx/nginx.conf</code></pre>
</div>

<style>
    .highlight-type {
        content: "Dockerfile";
        position: absolute;
        opacity: 0.5;
    }
</style><h3 id="docker-compose">Docker Compose</h3>
<p>The last piece missing is a <a href="https://docs.docker.com/compose/">Docker
Compose</a> file to help us run these containers:</p>
<div class="highlight">
    <span class="highlight-type">yaml</span>
    <pre><code class="language-yaml hljs" data-lang="yaml"># docker-compose.yaml
version: &#34;3.6&#34;
services:
  goservice:
    build: &#34;server.Dockerfile&#34;
    ports:
      - &#34;8080&#34;
  nginx:
    build: &#34;nginx.Dockerfile&#34;
    ports:
      - &#34;80:80&#34;
    depends_on:
      - &#34;goservice&#34;</code></pre>
</div>

<style>
    .highlight-type {
        content: "yaml";
        position: absolute;
        opacity: 0.5;
    }
</style><h3 id="running-and-testing">Running and testing</h3>
<p>After setting up our environment we can test it by running the commands below:</p>
<ul>
<li><code>docker-compose up --build</code> to run our containers</li>
<li><code>curl localhost</code> to make a request to our server</li>
</ul>
<p>Voil√°! The error shows up confirming our theory!</p>
<div class="highlight">
    <span class="highlight-type">nil</span>
    <pre><code class="language-nil hljs" data-lang="nil">goservice_1  | 2022/04/07 01:12:14 error writing: write tcp 172.18.0.2:8080-&gt;172.18.0.3:56768: write: broken pipe</code></pre>
</div>

<style>
    .highlight-type {
        content: "nil";
        position: absolute;
        opacity: 0.5;
    }
</style><h2 id="conclusion">Conclusion</h2>
<p>This was a lot of fun to figure it! As noted by our tests the timeout
configuration of our cluster&rsquo;s reverse proxy was indeed the issue, overriding
the timeout settings with the snippet below solved the issue instantly!</p>
<div class="highlight">
    <span class="highlight-type">yaml</span>
    <pre><code class="language-yaml hljs" data-lang="yaml">apiVersion: configuration.konghq.com/v1
kind: KongIngress
metadata:
  annotations:
    kubernetes.io/ingress.class: &#34;kong&#34;
  name: kong-timeout-conf
proxy:
  connect_timeout: 10000000 # 10 minutes
  protocol: http
  read_timeout: 10000000
  retries: 10
  write_timeout: 10000000
---
apiVersion: v1
kind: Service
metadata:
  annotations:
    konghq.com/override: kong-timeout-conf</code></pre>
</div>

<style>
    .highlight-type {
        content: "yaml";
        position: absolute;
        opacity: 0.5;
    }
</style><footer>
    <p><em>
        Have something to say about this? Feel free to send me an email at
        <a href="mailto:~glorifiedgluer/inbox@lists.sr.ht">my inbox</a>!
    </em></p>
</footer>

      </main>
    </main>
  </body>
</html>
