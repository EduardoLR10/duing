<!DOCTYPE html>
<html class="" lang="en"><head>
    
    <meta name="viewport" content="width=device-width" />
    <meta http-equiv="Content-Type" content="text/html;charset=UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=7" />

    <link
    rel="icon"
    href='/favicon.png'
/>
<link
    rel="shortcut icon"
    href='/favicon.ico'
    type="image/x-icon"
/>
<link
    rel="apple-touch-icon"
    href='/apple-touch-icon.png'
/>

    <link
        rel="icon"
        href='/logo.svg'
        type="image/svg+xml"
    />

<title>
        
            Zigging out of Lambdas  &ndash;
        
        Duing Dev
    </title>

    
    <link href="/symbols-nerd-font/symbols-nerd-font.css" rel="stylesheet" integrity="sha512-lydow8GLOLlYNOtHlksNCmGWWCBsbIEtikXpHzfWqx78HLlyQZHOzyLwPpKol4Th6aCwLUXOfODVYgwrd3nwKQ=="/>
    <link href="/jetbrains-mono/jetbrains-mono.css" rel="stylesheet" integrity="sha512-tJxlgL6v1Y7kFf+qB8SloaAMKnOAw6WouknxXtIjkBux9Y/9aX81EUWOJO8c/3l98DmjG8brr4to7zaez606Fg=="/>

    
    
    <link type="text/css" rel="stylesheet" href=https://duing.dev/css/styles.6f7510796ff02c7dabd794e74edd5fe8768c226a0caad05f3838da994c532544d6915ce65b106ca5a210796f2936429e8446811360103cd082ad0dc245016d71.css integrity="sha512-b3UQeW/wLH2r15TnTt1f6HaMImoMqtBfODjamUxTJUTWkVzmWxBspaIQeW8pNkKehEaBE2AQPNCCrQ3CRQFtcQ==" />
<meta name="author" content="Eduardo Lemos Rocha" />

    
        <meta name="keywords" content='lesson, recommendation' />
    
    
        <meta name="description" content="ic way to implement a particular functionality. In the process of implementing it, however, you notice that some pieces of the code really bother you. Not because they are wrong, stuff works and all, but because it feels like you had to bend the tool you are using to get the result. It is not the most pleasant type of hacking. This post is about an experience of this phenomena." />
    

<meta property="og:site_name"
    content='Duing Dev' />

    <meta property="og:title" content="Zigging out of Lambdas" />
    <meta property="og:type" content="article" />
    
    <meta
        property="article:author" content="Eduardo Lemos Rocha" />
    <meta
        property="article:published_time"
        content='2024-08-01T00:00:00Z&#43;0000' />
    
        
            <meta property="article:tag" content="lesson" />
        
            <meta property="article:tag" content="recommendation" />
        
    
    <meta property="og:url" content="https://duing.dev/posts/zigginglambdas/" />
    
    
    <meta property="og:image"
        content="https://duing.dev/img/icon.svg" />
    
        <meta property="og:description" content="You envision a generic way to implement a particular functionality. In the process of implementing it, however, you notice that some pieces of the code really b" />
    

<meta name="twitter:card" content="summary_large_image" />
<meta property="twitter:domain"
      content='duing.dev'
/>
<meta property="twitter:url" content="https://duing.dev/posts/zigginglambdas/" />


    <meta name="twitter:title" content="Zigging out of Lambdas" />
    
    
    
    <meta name="twitter:image"
        content="https://duing.dev/img/icon.svg" />
    
        <meta name="twitter:description" content="You envision a generic way to implement a particular functionality. In the process of implementing it, however, you notice that some pieces of the code really b" />
    

<link rel="manifest" href="/manifest/index.json" />
</head>


<body>
        <div id="baseContainer"><header class="">
<div class="titleAndSearchContainer">
        <div id="titleContainer">
            
                <a class="unstyledLink" href="/">
                    <img src='/logo.svg' alt='Logo'/>
                </a>
            
            <div class="rightOfLogo">
                <div class="titleAndHamburger">
                    <h1>
                        <a class="unstyledLink" href="/">Duing Dev</a>
                        
                    </h1>
                    
                </div>
                <div id="wide_nav"><nav>
    
    <ul id="main-nav">
        <li><a href="/">Home</a></li>
        
            <li><a href="/posts">Posts</a></li>
        
        
        
        
        
            <li><a href="https://duing.dev/publications/">
                Publications
            </a></li>
        
            <li><a href="https://duing.dev/about/">
                About
            </a></li>
        
        
        
            <li><a href="/tags">Tags</a></li>
        
        
    </ul>
</nav>
</div>
            </div>
        </div>
        
    </div>
    <div id="links">
        
        
        <a
    
        rel="noreferrer"
    
    target="_blank"
    class="nerdlink"
    href="mailto:dudulr10@gmail.com">
    
    
        &#xf6ed;
    
    <span>
        Email
    </span>
</a>
<a
    
        rel="noreferrer"
    
    target="_blank"
    class="nerdlink"
    href="https://github.com/EduardoLR10">
    
    
        &#xf09b;
    
    <span>
        GitHub
    </span>
</a>
<a
    
        rel="noreferrer"
    
    target="_blank"
    class="nerdlink"
    href="https://discordapp.com/users/246675375877390337">
    
    
        &#xfb6e;
    
    <span>
        Discord
    </span>
</a>
<a
    
        rel="noreferrer"
    
    target="_blank"
    class="nerdlink"
    href="https://www.linkedin.com/in/eduardo-lemos-rocha-3198a5149/">
    
    
        &#xf0e1;
    
    <span>
        Linkedin
    </span>
</a>
<a
    
        rel="noreferrer"
    
    target="_blank"
    class="nerdlink"
    href="https://www.youtube.com/channel/UCMyzdYsPiBU3xoqaOeahr6Q">
    
    
        &#xf16a;
    
    <span>
        Dr.Nekoma
    </span>
</a>

    </div>
    

</header>
<div id="contentContainer">
                <div id="content">
                    <main>
<article class="card single">
    
        <h1>Zigging out of Lambdas</h1>
    
    
        <p class="date">
            <span title='Date'> </span>
    2024-08-01

</p>
    
    
    
    
    <div><p>You envision a generic way to implement a particular functionality.
In the process of implementing it, however, you notice that some pieces of the code
really bother you. Not because they are <em>wrong</em>, stuff works and all, but because it
feels like you had to bend the tool you are using to get the result. It is not the most
pleasant type of hacking. This post is about an experience of this phenomena.</p>
<p>In the spirit of having a more concrete example of my previous post, <a href="../defaultsAreNotDogmas/">Don&rsquo;t make all defaults Dogmas</a>,
today I will describe a very small feature I had to implement in one of my personal projects, and how
the initial version that I <strong>wanted</strong> to implement turned out not that amazing due to how uncomfortable I was
after using some magical tricks to make it happen.</p>
<h2 id="context">Context</h2>
<p>You are making your game, implemented in Zig, during your free time after work. In this particular session, the
hanging fruit is some sort of <em>asset loader</em>. You want to have a very nice interface that you pass the file path
of the asset, that being an image, audio, model, texture, etc, and the function just returns it. To make
the experience nice for the caller of the function, we will prefix the provided file path with some sort of <em>base file path</em>,
so then if the assets&rsquo; folder moves to somewhere else in the file system, only the loading functions for assets need to change, nothing else.</p>
<h2 id="first-implementation">First Implementation</h2>
<p>Let&rsquo;s decide that the first draft will be for image loading. We come up with this as our first attempt:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-zig" data-lang="zig"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> rl <span style="color:#f92672">=</span> @import(<span style="color:#e6db74">&#34;raylib&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> std <span style="color:#f92672">=</span> @import(<span style="color:#e6db74">&#34;std&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> base_filepath <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;./assets/&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> checkExtension(filePath<span style="color:#f92672">:</span> [<span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>]<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">u8</span>, extensions<span style="color:#f92672">:</span> []<span style="color:#66d9ef">const</span> [<span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>]<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">u8</span>) <span style="color:#66d9ef">bool</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> fileExtension <span style="color:#f92672">=</span> std.fs.path.extension(filePath);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (extensions) <span style="color:#f92672">|</span>extension<span style="color:#f92672">|</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (std.mem.eql(<span style="color:#66d9ef">u8</span>, fileExtension, extension)) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> image(imageFilePath<span style="color:#f92672">:</span> [<span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>]<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">u8</span>) <span style="color:#f92672">!</span>rl.Image {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> allocator<span style="color:#f92672">:</span> std.mem.Allocator <span style="color:#f92672">=</span> std.heap.c_allocator;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> fullFilePath <span style="color:#f92672">=</span> <span style="color:#66d9ef">try</span> std.fs.path.joinZ(allocator, <span style="color:#f92672">&amp;</span>.{ base_filepath, imageFilePath });
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">defer</span> allocator.free(fullFilePath);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (checkExtension(imageFilePath, <span style="color:#f92672">&amp;</span>.{ <span style="color:#e6db74">&#34;.png&#34;</span>, <span style="color:#e6db74">&#34;.jpg&#34;</span> })) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> rl.loadImage(fullFilePath);
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        std.debug.print(<span style="color:#e6db74">&#34;Error trying to load image: .{s}&#34;</span>, .{fullFilePath});
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">error</span>.could_not_load_image;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>With the image&rsquo;s file path on hand, we first instantiate an <code>allocator</code>. We&rsquo;ll use it to create the full file path of the
asset, i.e., add the prefix <code>base_filepath</code>. This string will have no use after we load the image, hence we <code>defer</code> to free it.
Just before we load the asset, we do a naive check of the provided file. Only files with the extension <code>&quot;.png&quot;</code> or <code>&quot;.jpg&quot;</code>
will have a chance to be loaded as an image. Otherwise, we just fail logging an error message for debugging purposes. When calling the function <code>image</code>,
within the Struct <code>assets</code> (files in Zig behave like Structs), the user will just call <code>assets.image(&quot;my_image.png&quot;);</code> and the job is done.</p>
<p>Now, imagine that you don&rsquo;t want to only have images: what about models? And textures? Well&hellip;</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-zig" data-lang="zig"><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> model(modelFilePath<span style="color:#f92672">:</span> [<span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>]<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">u8</span>) <span style="color:#f92672">!</span>rl.Model {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> allocator<span style="color:#f92672">:</span> std.mem.Allocator <span style="color:#f92672">=</span> std.heap.c_allocator;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> fullFilePath <span style="color:#f92672">=</span> <span style="color:#66d9ef">try</span> std.fs.path.joinZ(allocator, <span style="color:#f92672">&amp;</span>.{ base_filepath, modelFilePath });
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">defer</span> allocator.free(fullFilePath);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (checkExtension(modelFilePath, <span style="color:#f92672">&amp;</span>.{ <span style="color:#e6db74">&#34;.glb&#34;</span>, <span style="color:#e6db74">&#34;.obj&#34;</span> })) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> rl.loadModel(fullFilePath);
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        std.debug.print(<span style="color:#e6db74">&#34;Error trying to load model: .{s}&#34;</span>, .{fullFilePath});
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">error</span>.could_not_load_model;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> texture(textureFilePath<span style="color:#f92672">:</span> [<span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>]<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">u8</span>) <span style="color:#f92672">!</span>rl.Texture2D {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> allocator<span style="color:#f92672">:</span> std.mem.Allocator <span style="color:#f92672">=</span> std.heap.c_allocator;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> fullFilePath <span style="color:#f92672">=</span> <span style="color:#66d9ef">try</span> std.fs.path.joinZ(allocator, <span style="color:#f92672">&amp;</span>.{ base_filepath, textureFilePath });
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">defer</span> allocator.free(fullFilePath);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (checkExtension(textureFilePath, <span style="color:#f92672">&amp;</span>.{ <span style="color:#e6db74">&#34;.png&#34;</span>, <span style="color:#e6db74">&#34;.jpg&#34;</span> })) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> rl.loadTexture(fullFilePath);
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        std.debug.print(<span style="color:#e6db74">&#34;Error trying to load texture: .{s}&#34;</span>, .{fullFilePath});
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">error</span>.could_not_load_texture;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Underwhelming, isn&rsquo;t it? We have <strong>three</strong> functions that have more similarities than differences. In fact,
most of the bodies of these functions are identical. The boilerplate is palpable. What can we do to improve this?</p>
<h2 id="different-mindset">Different Mindset</h2>
<p>You, being a Functional Programming (FP) fan, had an idea. What if we use the powers of lambdas and type programming to make things
more generic? After some thinking, you ended up with this draft:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-zig" data-lang="zig"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> rl <span style="color:#f92672">=</span> @import(<span style="color:#e6db74">&#34;raylib&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> std <span style="color:#f92672">=</span> @import(<span style="color:#e6db74">&#34;std&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> base_filepath <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;./assets/&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> load(<span style="color:#66d9ef">comptime</span> filePath<span style="color:#f92672">:</span> [<span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>]<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">u8</span>, <span style="color:#66d9ef">comptime</span> T<span style="color:#f92672">:</span> <span style="color:#66d9ef">type</span>, loader<span style="color:#f92672">:</span> <span style="color:#66d9ef">fn</span> ([<span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>]<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">u8</span>) T, predicate<span style="color:#f92672">:</span> <span style="color:#66d9ef">fn</span> ([<span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>]<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">u8</span>) <span style="color:#66d9ef">bool</span>) <span style="color:#f92672">!</span>T {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> allocator<span style="color:#f92672">:</span> std.mem.Allocator <span style="color:#f92672">=</span> std.heap.c_allocator;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> fullFilePath <span style="color:#f92672">=</span> <span style="color:#66d9ef">try</span> std.fs.path.joinZ(allocator, <span style="color:#f92672">&amp;</span>.{ base_filepath, filePath });
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">defer</span> allocator.free(fullFilePath);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (predicate(fullFilePath)) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> loader(fullFilePath);
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        std.debug.print(<span style="color:#e6db74">&#34;Error trying to load file: .{s}&#34;</span>, .{fullFilePath});
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">error</span>.could_not_load_asset;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> checkExtension(extensions<span style="color:#f92672">:</span> []<span style="color:#66d9ef">const</span> [<span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>]<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">u8</span>) (<span style="color:#66d9ef">fn</span> ([<span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>]<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">u8</span>) <span style="color:#66d9ef">bool</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">fn</span> check(filePath<span style="color:#f92672">:</span> [<span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>]<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">u8</span>) <span style="color:#66d9ef">bool</span> {
</span></span><span style="display:flex;"><span>	    <span style="color:#66d9ef">const</span> fileExtension <span style="color:#f92672">=</span> std.fs.path.extension(filePath);
</span></span><span style="display:flex;"><span>	    <span style="color:#66d9ef">for</span> (extensions) <span style="color:#f92672">|</span>extension<span style="color:#f92672">|</span> {
</span></span><span style="display:flex;"><span>	        <span style="color:#66d9ef">if</span> (std.mem.eql(<span style="color:#66d9ef">u8</span>, fileExtension, extension)) {
</span></span><span style="display:flex;"><span>		    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>	        }
</span></span><span style="display:flex;"><span>	    }
</span></span><span style="display:flex;"><span>	    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>    }.check;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> image(<span style="color:#66d9ef">comptime</span> imageFilePath<span style="color:#f92672">:</span> [<span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>]<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">u8</span>) <span style="color:#f92672">!</span>rl.Image {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> load(imageFilePath, rl.Image, rl.loadImage, checkExtension(<span style="color:#f92672">&amp;</span>.{ <span style="color:#e6db74">&#34;.png&#34;</span>, <span style="color:#e6db74">&#34;.jpg&#34;</span> }));
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> model(<span style="color:#66d9ef">comptime</span> modelFilePath<span style="color:#f92672">:</span> [<span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>]<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">u8</span>) <span style="color:#f92672">!</span>rl.Model {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> load(modelFilePath, rl.Model, rl.loadModel, checkExtension(<span style="color:#f92672">&amp;</span>.{ <span style="color:#e6db74">&#34;.glb&#34;</span>, <span style="color:#e6db74">&#34;.obj&#34;</span> }));
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> texture(<span style="color:#66d9ef">comptime</span> textureFilePath<span style="color:#f92672">:</span> [<span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>]<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">u8</span>) <span style="color:#f92672">!</span>rl.Texture2D {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> load(textureFilePath, rl.Texture2D, rl.loadTexture, checkExtension(<span style="color:#f92672">&amp;</span>.{ <span style="color:#e6db74">&#34;.png&#34;</span>, <span style="color:#e6db74">&#34;jpg&#34;</span> }));
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Although a little different than primary FP languages, we managed to shrink a lot code, basically eliminating
the previous boilerplate. This didn&rsquo;t come for <em>free</em> though, as we are about to see later on.</p>
<p>Most of the functionality now lives under a function called <code>load</code>, which is not being exposed for the user. This function
requires: the asset&rsquo;s file path, the type of the data we will return (we&rsquo;re using Zig&rsquo;s compile-time reflection here), which
loading function we will use, and finally a predicate to validate the file before loading. To make things simple, we are doing
the same extension check as before.</p>
<p>At first glance, we did it. But, why do I look at that and feel that something is wrong although it works?</p>
<h2 id="trade-offs">Trade-Offs</h2>
<p>The latest implementation, although it compiles and it works, feels uneasy to read. A few tricks were required to make it work:
we introduced Zig&rsquo;s reflection to the party <strong>only</strong> to be able to have generic returns (we need to bind the return type to a name).
Did anybody noticed <code>checkExtension</code>? This function is using a very specific trick [1]. Since Struct declarations are anonymous, we&rsquo;ve
declared a Struct and immediately return a member function from it. This way we can keep the argument of the outter function, <code>extensions</code>,
still in scope and return another function from it. We use this later in <code>load</code> as our predicate of choice (you could do something way fancier,
like checking the internal header of the file, etc).</p>
<p>The first implementation, although with heavy boilerplate, even has some advantages: our error messages are more precise about which asset failed
to load, rather than just saying &ldquo;failed to load a generic file&rdquo;, there is no ~comptime~s floating around, even if they were simple ones, and there
is no Struct hack to have anonoymous lambdas in the code.</p>
<h2 id="conclusion">Conclusion</h2>
<p>At this point, my mind uses FP as my default for everything. My mind works like this:</p>
<figure><img src="/img/ziggingLambdas/mind.png" width="60%"/>
</figure>

<p>However, when faced with a particular set of tools, specially imperative ones, I find that trying to follow my default with no exceptions can lead
to less maintanable, predictable, and efficient code. The latter aspect, in terms of its importance, may vary from application to application, but the first
two points basically always matter. If the tool that I&rsquo;m suppose to use comes with a specific set of premises, I gotta be careful about not following them.</p>
<p>Doing the development of this game, this was the second time this happened. The first time it was about using or not a clear and pure separation between
the game&rsquo;s logic and its render (I mentioned this case in the post  <a href="../defaultsAreNotDogmas/">Don&rsquo;t make all defaults Dogmas</a>). Now, it was about asset loading management.</p>
<p>It may be the case that somewhere in the wild, there is a silver bullet on the corner; a tool so flexible that it fits into everything. I&rsquo;ll write a blog post
when and if I happen to find it.</p>
<h2 id="references">References</h2>
<ol>
<li><a href="https://ziggit.dev/t/anonymous-functions-lambdas/1087/2">https://ziggit.dev/t/anonymous-functions-lambdas/1087/2</a></li>
</ol>
</div>
</article>

    <hr />
    <p class="articleTagsContainer">
        <span> </span>
        <strong>Tags:</strong>
        
            <a
                
                href="/tags/lesson">#lesson</a>
        
            <a
                
                href="/tags/recommendation">#recommendation</a>
        
    </p>






                    </main><footer>
    <hr />

<p><small>
        2024 &copy; 
    </small></p>
    <p><small>
        <a href='https://gitlab.com/gabmus/hugo-ficurinia'>Ficurinia theme</a> for <a href='https://gohugo.io'>Hugo</a> by <a href='https://gabmus.org'>Gabriele Musco</a>. Licensed under <a href='https://www.gnu.org/licenses/agpl-3.0.html'>GNU AGPLv3</a>.
    </small></p>
</footer>
</div>
            </div>
        </div>


</body>
</html>
